#   참조 : 자료구조와 함께 배우는 알고리즘 입문
#   1주차 1조 팀원들과 함께 토론함

N = int(input())
pos = [0] * N  # 각 열마다 퀸 위치를 저장하는 배열
flag = [False] * N  # 행 사용 여부를 체크하는 배열, flag[j]가 True면 j행에 퀸이 있음
diag_up = [False] * (2*N - 1)  # 대각선(↘)체크, 크기 2N-1은 가능한 대각선 개수
diag_down = [False] * (2*N - 1)  # 왼쪽 아래 대각선(↙) 충돌 체크, 역시 크기 2N-1
count = 0  # 퀸을 배치할 수 있는 해의 개수를 카운팅하는 전역 변수


# i: 현재 퀸을 배치하려는 열 번호 (0부터 N-1까지), 재귀적으로 퀸을 배치
def set(i):
    global count  # 함수 내에서 값을 증가시키기 위해 global 선언
    for j in range(N):  # j: i열에서 퀸을 놓을 행 번호를 탐색 (0부터 N-1까지)
        # (i, j)에 퀸을 놓을 수 있는지 안전성 체크
        if (not flag[j] and  # j행에 퀸이 아직 없어야 함
            not diag_up[i-j + N-1] and  # (i, j)가 대각선(↘)에서 공격받지 않아야 함
            not diag_down[i+j]):  # (i, j)가 대각선(↙)에서 공격받지 않아야 함
            pos[i] = j  # i열의 퀸을 j행에 배치
            if i == N-1:  # i가 마지막 열(N-1)에 도달했으면 모든 퀸 배치 완료
                count += 1  # 유효한 해 하나 발견
            else:  # 아직 마지막 열이 아니면 다음 열로 진행
                flag[j] = True  # j행에 퀸을 놓았으니 사용 중 표시, 다른 열에서 j행 사용 불가
                diag_up[i-j + N-1] = True  # 왼쪽 위 대각선(↘) 충돌 표시
                # i-j + N-1: 대각선 인덱스 계산, i-j는 -N+1 ~ N-1 범위, N-1 더해 0 ~ 2N-2로 조정(음수가 되면 안되니)
                diag_down[i+j] = True  # 오른쪽 위 대각선(↙) 충돌 표시
                # i+j: 대각선 인덱스, 0 ~ 2N-2 범위, 이미 양수라 조정 필요 X
                set(i + 1)  # 다음 열(i+1)로 이동해 퀸 배치 시도, 재귀 호출
                # 백트래킹: set(i+1)의 모든 탐색이 끝났으니 현재 선택을 되돌림
                flag[j] = False  # j행의 퀸 제거, 해당 행 다시 사용 가능
                diag_up[i-j + N-1] = False  # 왼쪽 위 대각선 충돌 표시 해제, 다음 시도를 위해 복구
                diag_down[i+j] = False  # 오른쪽 위 대각선 충돌 표시 해제, 다음 시도를 위해 복구

set(0)
print(count)  # 해의 개수 출력
"""
입력
첫 줄에 물품의 수 N(1 ≤ N ≤ 100), 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)
두번째 줄부터 N개의 줄에 걸쳐 물건의 무게 W(1 ≤ W ≤ 100,000)와
해당 물건의 가치 V(0 ≤ V ≤ 1,000)

출력
배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력

물건은 '각 물건은 무한히 많다'(unbounded) 또는 '각 물건은 최대 X까지'(bounded)라는
추가적인 명시가 없으면 중복 선택 불가(0-1 Knapsack) 문제로 판단한다.

두번째 줄부터 물건의 정보를 저장해야 하는데...
그 전에 2차원 배열을 만들어야 할 것 같습니다. N+1행, K+1열로.

그리고 things 라는 리스트를 딕셔너리를 만들어야 하나? {1: (4,7)} 이런 느낌으로?
하지만 이러면 무게나 가치 접근이 번거롭고 느릴 수 있으니
1based 인덱스를 위해 value = [0], weight =[0] 리스트를 선언과 동시에 초기화하고
물품의 수 N번만큼 for문을 돌려서
W와 V를 int형으로 언패킹 및 맵칭하고,
weight 리스트에는 weight.append(W)
value 리스트에는 value.append(V)로 저장해야 할 듯...!

그래야 점화식에서
dp[i-1][w - weight[i]] + value[i]처럼 쉽게 접근을 할 수 있을테니까
리스트를 3개 쓰는 게 번거롭지만...

i번째 물건까지 고려했을 때 총 무게 w로 만들 수 있는 최대 가치의 점화식

dp[i][w] = max(
dp[i-1][w],     # i번째 물건을 담지 않았을 때
dp[i-1][w-weight[i]] + value[i])    #i번째 물건을 담았을 때

for문으로 돌리는데 2차원 배열이기에 이중 for문이어야 함
고르지 않을 때와 최대 무게가 0일 때를 고려해야 하기에 각각 레인지는 N+1, K+1
초기값은 당연히 아무 것도 고르지 않았을 때 dp[0][w] = 0
현재 담을 수 있는 최대 무게 dp[i][0] = 0

그리고 분기는 두개로 나뉘는데
현재 선택한 물건의 무게가 현재 담을 수 있는 무게 w보다 작을 때 -> 물건을 선택하지 않거나 현재 물건을 선택하거나 둘 중 가치가 큰 것을 선택할 수 있음
근데 현재 선택한 물건의 무게가 현재 담을 수 있는 무게 w보다 클 때는 때려 죽어도 선택할 수 없으므로 이전 결과(dp[i-1][w])를 그대로 가져와야 함

문제에서는
배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력을 원하니까
max(dp[N])을 print하면 될 듯
"""
N, K = map(int, input().strip().split())

dp = [[0]*(K + 1) for _ in range (N + 1)]
weight = [0]
value = [0]

for i in range(N):
    W, V = map(int, input().strip().split())
    weight.append(W)
    value.append(V)

for i in range(N + 1):
    for w in range(K + 1):
        dp[0][w] = 0
        dp[i][0] = 0
        if  w >= weight[i]:
            dp[i][w] = max(
                dp[i-1][w],# 현재 물건을 선택하지 않음
                dp[i-1][w - weight[i]] + value[i]  # 현재 물건 선택
            )
        else:
            dp[i][w] = dp[i-1][w]

print(max(dp[N]))
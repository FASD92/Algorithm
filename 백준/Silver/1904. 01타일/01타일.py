"""
상태 정의 : dp[i] = i번째 피보나치 수
점화식 : dp[i] = dp[i-1] + dp[i-2]
초기값 : dp[0] = 0, dp[1]=1, dp[2]=2
최종값 : dp[n]

구현방식 : 타뷸레이션
이전 값 두 개(dp[n-1],dp[n-2])만 저장하면 되므로 공간도 O(1)까지 최적화 가능
호출 스택 없어서 안정적이고 빠름

인덱스 에러가 계속 떠서 보니 초기값일 때 처리를 제대로 안 함
피보나치 수열 때는 dp[0]일 때와 dp[1]일 때 초기값 2개가 필요했음 -> f(2)부터는 f(1)과 f(2)만 있으면 되니까
그래서 01타일도 피보나치와 점화식이 같으니까 그렇게 하면 될 거라 생각했음
하지만 피보나치 수열은 말 그대로 정의된 규칙대로 숫자를 만드는 거고
01타일은 모든 경우의 수를 세는 것이기 때문에 아예 똑같이 생각하면 안 됨!

또한 01타일에서 N은 1부터 주어지고, 그러므로 dp[1]과 dp[2]가 핵심 초기값!
그래서 n=1이나 n=2일 때는 DP 테이블 만들 필요 없이 바로 정답 출력
n=1도 아니고 n=2도 아닐 때 그제서야 배열을 만듦
"""
n = int(input())
M = 15746

if n == 1:
    print(1)
elif n == 2:
    print(2)
else:
    dp = [0] * (n+1)
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n+1):
        dp[i] = (dp[i-1] + dp[i-2]) % M
    print(dp[n])